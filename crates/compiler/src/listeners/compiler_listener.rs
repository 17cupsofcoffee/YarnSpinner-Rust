use crate::prelude::*;
use antlr_rust::token::Token;
use antlr_rust::tree::{ParseTreeListener, ParseTreeVisitorCompat};
use rusty_yarn_spinner_core::prelude::*;
use std::collections::HashSet;
mod emit;
use crate::parser::generated::yarnspinnerparser::{
    BodyContext, HeaderContext, NodeContext, YarnSpinnerParserContextType,
};
use crate::prelude::generated::yarnspinnerparser::BodyContextAttrs;
use crate::prelude::generated::yarnspinnerparserlistener::YarnSpinnerParserListener;
use crate::visitors::CodeGenerationVisitor;
pub(crate) use emit::*;

pub(crate) struct CompilerListener<'a, 'input: 'a> {
    /// The current node to which instructions are being added.
    pub(crate) current_node: Option<Node>,
    /// The current debug information that describes [`current_node`].
    current_debug_info: DebugInfo,
    pub(crate) debug_infos: Vec<DebugInfo>,

    /// Whether we are currently parsing the
    /// current node as a 'raw text' node, or as a fully syntactic node.
    pub(crate) raw_text_node: bool,

    pub(crate) diagnostics: Vec<Diagnostic>,

    file_parse_result: FileParseResult<'a>,
    pub(crate) tokens: &'a ActualTokenStream<'input>,
    /// The program being generated by the compiler.
    pub(crate) program: Program,
    label_count: usize,

    // the list of nodes we have to ensure we track visitation
    tracking_nodes: HashSet<String>,
}

impl<'a, 'input: 'a> CompilerListener<'a, 'input> {
    /// Generates a unique label name to use in the program.
    ///
    /// ## Params
    /// - `commentary` Any additional text to append to the
    /// end of the label.
    pub(crate) fn register_label<'b>(&mut self, commentary: impl Into<Option<&'b str>>) -> String {
        self.label_count += 1;
        let commentary = commentary.into().unwrap_or_default();
        format!("L{}{}", self.label_count, commentary)
    }
}

impl<'a, 'input: 'a> ParseTreeListener<'input, YarnSpinnerParserContextType>
    for CompilerListener<'a, 'input>
{
}

impl<'a, 'input: 'a> YarnSpinnerParserListener<'input> for CompilerListener<'a, 'input> {
    fn enter_node(&mut self, _ctx: &NodeContext<'input>) {
        // we have found a new node set up the currentNode var ready to
        // hold it and otherwise continue
        self.current_node = Some(Node {
            name: Default::default(),
            instructions: Default::default(),
            labels: Default::default(),
            tags: Default::default(),
            source_text_string_id: Default::default(),
            headers: Default::default(),
        });
        self.current_debug_info = Default::default();
        self.raw_text_node = false;
    }

    fn exit_node(&mut self, ctx: &NodeContext<'input>) {
        let name = &self.current_node.as_ref().unwrap().name.clone();
        if name.is_empty() {
            // We don't have a name for this node. We can't emit code for
            // it.
            self.diagnostics.push(
                Diagnostic::from_message("Missing title header for node")
                    .with_file_name(self.file_parse_result.name.clone())
                    .read_parser_rule_context(ctx, self.tokens),
            );
        } else {
            if !self.program.nodes.contains_key(name) {
                self.program
                    .nodes
                    .insert(name.clone(), self.current_node.clone().unwrap());
            } else {
                // Duplicate node name! We'll have caught this during the
                // declarations pass, so no need to issue an error here.
            }
            self.current_debug_info.node_name = name.clone();
            self.current_debug_info.file_name = self.file_parse_result.name.clone();
            self.debug_infos.push(self.current_debug_info.clone());
        }
        self.current_node = None;
        self.raw_text_node = false;
    }

    fn exit_header(&mut self, ctx: &HeaderContext<'input>) {
        // have finished with the header so about to enter the node body
        // and all its statements do the initial setup required before
        // compiling that body statements eg emit a new startlabel
        let header_key = ctx.header_key.as_ref().unwrap().get_text();
        let current_node = self.current_node.as_mut().unwrap();

        // Use the header value if provided, else fall back to the
        // empty string. This means that a header like "foo: \n" will
        // be stored as 'foo', '', consistent with how it was typed.
        // That is, it's not null, because a header was provided, but
        // it was written as an empty line.
        let header_value = ctx
            .header_value
            .as_ref()
            .map(|v| v.get_text())
            .unwrap_or_default()
            .to_owned();
        match header_key {
            "title" => {
                // Set the name of the node
                current_node.name = header_value.clone();
            }
            "tags" => {
                // Split the list of tags by spaces, and use that
                let tags = header_value.split(' ').map(|s| s.to_owned());
                current_node.tags.extend(tags);
                if current_node.tags.contains(&"rawText".to_owned()) {
                    // This is a raw text node. Flag it as such for future compilation.
                    self.raw_text_node = true;
                }
            }
            _ => {}
        }
        let header = Header {
            key: header_key.to_owned(),
            value: header_value,
        };
        current_node.headers.push(header);
    }

    fn enter_body(&mut self, ctx: &BodyContext<'input>) {
        let current_node = self.current_node.as_mut().unwrap();
        // ok so something in here needs to be a bit different
        // also need to emit tracking code here for when we fall out of a node that needs tracking?
        // or should do I do in inside the codegenvisitor?

        // if it is a regular node
        if !self.raw_text_node {
            // This is the start of a node that we can jump to. Add a
            // label at this point
            current_node.labels.insert(
                self.register_label(None),
                current_node.instructions.len() as i32,
            );
            let track = (self.tracking_nodes.contains(&current_node.name))
                .then(|| Library::generate_unique_visited_variable_for_node(&current_node.name));

            let mut visitor = CodeGenerationVisitor::new(self, track);
            for statement in ctx.statement_all() {
                visitor.visit(&*statement);
            }
        } else {
            // We are a rawText node. Don't compile it; instead, note the
            // string
            current_node.source_text_string_id = get_line_id_for_node_name(&current_node.name);
        }
    }
}
