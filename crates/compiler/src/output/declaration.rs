//! Adapted from <https://github.com/YarnSpinnerTool/YarnSpinner/blob/da39c7195107d8211f21c263e4084f773b84eaff/YarnSpinner.Compiler/Declaration.cs>
//!
//! ## Implementation notes
//!
//! [`Range`] has been replaced with the more idiomatic [`RangeInclusive<Position>`].

use crate::prelude::Diagnostic;
use antlr_rust::token::Token;
use rusty_yarn_spinner_core::prelude::convertible::Convertible;
use rusty_yarn_spinner_core::types::Type;
use std::cell::Ref;
use std::fmt::Display;
use std::ops::RangeInclusive;

/// Information about a declaration. Stored inside a declaration table,
/// which is produced from the Compiler.
///
/// You do not create instances of this class yourself. They are
/// generated by the [`Compiler`].
#[derive(Debug, Clone, PartialEq)]
pub struct Declaration {
    /// The name of this declaration.
    pub name: String,

    /// The default value of this declaration, if no value has been
    /// specified in code or is available from a [`Dialogue`]'s
    /// [`IVariableStorage`].
    pub default_value: Convertible,

    /// A string describing the purpose of this declaration.
    pub description: Option<String>,

    /// The name of the file in which this declaration was found.
    ///
    /// If this declaration was not found in a Yarn source file, this
    /// will be [`DeclarationSource::External`].
    pub source_file_name: DeclarationSource,

    /// The name of the node in which this declaration was found.
    ///
    /// If this declaration was not found in a Yarn source file, this
    /// will be [`None`].
    pub source_node_name: Option<String>,

    /// A value indicating whether this declaration was implicitly
    /// inferred from usage.
    ///
    /// If `true`, this declaration was implicitly inferred from usage.
    /// If `false`, this declaration appears in the source code.
    pub is_implicit: bool,

    /// The type of the variable, as represented by an object found
    /// in a variant of [`Type`].
    pub r#type: Type,

    /// The range of text at which this declaration occurs.
    ///
    /// This range refers to the declaration of the symbol itself, and
    /// not any syntax surrounding it. For example, the declaration
    /// `<<declare $x = 1>>` would have a range referring to the `$x`
    /// symbol.
    pub range: Option<RangeInclusive<Position>>,
}

impl Declaration {
    /// Gets the line number at which this Declaration was found in the
    /// source file.
    ///
    /// If this [`Declaration`] was not found in a Yarn source file,
    /// this will be [`None`].
    pub fn source_file_line(&self) -> Option<usize> {
        self.range.as_ref()?.start().line.into()
    }

    pub fn from_default_value(default_value: impl Into<Convertible>) -> Self {
        Self {
            default_value: default_value.into(),
            name: Default::default(),
            description: Default::default(),
            source_file_name: Default::default(),
            source_node_name: Default::default(),
            is_implicit: Default::default(),
            r#type: Default::default(),
            range: Default::default(),
        }
    }

    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = name.into();
        self
    }

    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    pub fn with_description_optional(mut self, description: impl Into<Option<String>>) -> Self {
        self.description = description.into();
        self
    }

    pub fn with_source_file_name(mut self, source_file_name: impl Into<DeclarationSource>) -> Self {
        self.source_file_name = source_file_name.into();
        self
    }

    pub fn with_source_node_name(mut self, source_node_name: impl Into<String>) -> Self {
        self.source_node_name = Some(source_node_name.into());
        self
    }
    pub fn with_source_node_name_optional(
        mut self,
        source_node_name: impl Into<Option<String>>,
    ) -> Self {
        self.source_node_name = source_node_name.into();
        self
    }

    pub fn with_implicit(mut self) -> Self {
        self.is_implicit = true;
        self
    }

    pub fn with_type(mut self, r#type: impl Into<Type>) -> Self {
        self.r#type = r#type.into();
        self
    }

    pub fn with_range(mut self, range: impl Into<RangeInclusive<Position>>) -> Self {
        self.range = Some(range.into());
        self
    }
}

/// The source of a declaration.
///
/// ## Implementation notes
///
/// In the original implementation, [`External`] is just a magic string.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub enum DeclarationSource {
    #[default]
    External,
    File(String),
}

impl From<String> for DeclarationSource {
    fn from(file_name: String) -> Self {
        Self::File(file_name)
    }
}

impl From<&str> for DeclarationSource {
    fn from(file_name: &str) -> Self {
        file_name.to_owned().into()
    }
}

/// Represents a position in a multi-line string.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Position {
    /// The zero-indexed line of this position.
    pub line: usize,

    /// The zero-indexed character number of this position.
    pub character: usize,
}

impl Position {
    pub fn from_token(token: Ref<impl Token + ?Sized>) -> Self {
        Self {
            // All positions are +1 compared to original implementation, but the result is the same.
            // I suspect the C# ANTLR implementation is 1-based while antlr4rust is 0-based.
            line: token.get_line() as usize,
            character: token.get_column() as usize + 1,
        }
    }
}

impl Display for DeclarationSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::External => write!(f, "(External)"),
            Self::File(file_name) => write!(f, "{}", file_name),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct DeferredTypeDiagnostic {
    name: String,
    diagnostic: Diagnostic,
}
